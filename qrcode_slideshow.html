<!DOCTYPE html>
    <html lang="ja">
    <head>
      <meta charset="UTF-8">
      <title>受付用QRコードスライドショー</title>
      <style>
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #111; color: #fff; font-family: sans-serif; }
        .slide-container { display: flex; flex-direction: column; justify-content: center; align-items: center; width: 100%; height: 100%; }
        #qr-image { max-width: 80vw; max-height: 80vh; border: 10px solid #fff; border-radius: 12px; }
        #qr-info { margin-top: 20px; font-size: 2rem; font-weight: bold; }
        #page { writing-mode: horizontal-tb}
        .instructions { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;}
      </style>
    </head>
    <body>
      <div class="slide-container">
        <img id="qr-image" src="" alt="QR Code">
        <p id="qr-info">No. <span id="page" contenteditable="true"></span><span id="allPage"></span></p>
      </div>
      <div class="instructions">
        <p>← → キーでQRコードを切り替え (F11キーで全画面表示推奨)</p>
      </div>

      <script>
        // const users = [{"id":"xoU5Av","src":"./qrcodes/xoU5Av.png"},{"id":"LTJpYL","src":"./qrcodes/LTJpYL.png"},{"id":"WNpGYu","src":"./qrcodes/WNpGYu.png"},{"id":"AdjcEP","src":"./qrcodes/AdjcEP.png"},{"id":"ODpbzt","src":"./qrcodes/ODpbzt.png"},{"id":"e3tC5t","src":"./qrcodes/e3tC5t.png"},{"id":"7eCqUD","src":"./qrcodes/7eCqUD.png"},{"id":"lPlWBe","src":"./qrcodes/lPlWBe.png"},{"id":"hmp5A7","src":"./qrcodes/hmp5A7.png"},{"id":"LU7XC9","src":"./qrcodes/LU7XC9.png"}];
        let currentIndex = 0;
        let users = [];
        let uri = "";

        const qrImage = document.getElementById('qr-image');
        const qrInfo = document.getElementById('qr-info');
        const page = document.getElementById('page');
        const allPage = document.getElementById('allPage');

        function showQr(index) {
          if (users.length === 0) return;
          if (index < 0) index = 0;
          if (index >= users.length) index = users.length - 1;
          currentIndex = index;
          const user = users[index];
          qrImage.src = `./img/qrcodes/${user.id}.png`;
          // qrInfo.textContent = `No. ${index + 1} / ${users.length}`;
          page.textContent = index + 1;
          allPage.textContent = ` / ${users.length}`;

        }

        document.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowUp') {
            showQr(currentIndex + 1);
          } else if (e.key === 'ArrowDown') {
            showQr(currentIndex - 1);
          }
        });

        page.addEventListener('input', (e) => {
          const val = parseInt(page.textContent);
          if (!isNaN(val)) {
            if (users.length === 0) return;
            if (index < 0) index = 0;
            if (index >= users.length) index = users.length - 1;
              currentIndex = index;
              const user = users[index];
              qrImage.src = `./img/qrcodes/${user.id}.png`;
          }
        });

        // WebSocket 関連
        let ws = null;
        let heartbeatIntervalId = null;
        let heartbeatTimeoutId = null;
        let reconnectTimer = null;
        let reconnectDelay = 1000;
        const MAX_RECONNECT_DELAY = 30000;
        const HEARTBEAT_INTERVAL = 20000; // 20s
        const HEARTBEAT_TIMEOUT = 10000;  // 10s

        function normalizeWsUri(u) {
          if (!u) return u;
          if (u.startsWith('ws://') || u.startsWith('wss://')) return u;
          // http/https -> ws/wss
          return u.replace(/^http/, 'ws');
        }

        function clearHeartbeat() {
          if (heartbeatIntervalId) { clearInterval(heartbeatIntervalId); heartbeatIntervalId = null; }
          if (heartbeatTimeoutId) { clearTimeout(heartbeatTimeoutId); heartbeatTimeoutId = null; }
        }

        function startHeartbeat() {
          clearHeartbeat();
          // 定期的に ping を送る（アプリケーションレベル）
          heartbeatIntervalId = setInterval(() => {
            try {
              if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'ping', ts: Date.now() }));
                // pong が来なければタイムアウトとみなして切断 -> 再接続処理へ
                if (heartbeatTimeoutId) clearTimeout(heartbeatTimeoutId);
                heartbeatTimeoutId = setTimeout(() => {
                  console.warn('heartbeat timeout, closing ws');
                  try { ws.close(); } catch (e) {}
                }, HEARTBEAT_TIMEOUT);
              }
            } catch (e) {
              console.error('heartbeat send error', e);
            }
          }, HEARTBEAT_INTERVAL);
        }

        function scheduleReconnect() {
          if (reconnectTimer) return;
          reconnectTimer = setTimeout(() => {
            reconnectTimer = null;
            console.log('attempt reconnect (delay %dms)', reconnectDelay);
            connectWebSocket();
            reconnectDelay = Math.min(MAX_RECONNECT_DELAY, reconnectDelay * 2);
          }, reconnectDelay);
        }

        function connectWebSocket() {
          if (!uri) return;
          const wsUri = normalizeWsUri(uri);
          // 既に接続中/接続試行中なら何もしない
          if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;
          try {
            ws = new WebSocket(wsUri);
          } catch (err) {
            console.error('WebSocket connect error', err);
            scheduleReconnect();
            return;
          }

          ws.addEventListener('open', () => {
            console.log('WebSocket connected', wsUri);
            // 接続成功したら再接続遅延をリセットしてハートビート開始
            reconnectDelay = 1000;
            startHeartbeat();
            // 必要ならクライアント状態を送信
            // ws.send(JSON.stringify({ type: 'hello', ts: Date.now() }));
          });

          ws.addEventListener('message', (ev) => {
            try {
              const msg = JSON.parse(ev.data);
              // アプリケーションレベルの pong に対処
              if (msg && msg.type === 'pong') {
                if (heartbeatTimeoutId) { clearTimeout(heartbeatTimeoutId); heartbeatTimeoutId = null; }
                return;
              }
              // 任意のメッセージ受信で heartbeat タイムアウトをクリア
              if (heartbeatTimeoutId) { clearTimeout(heartbeatTimeoutId); heartbeatTimeoutId = null; }
              console.log('WebSocket message received', msg);
              showQr(currentIndex + 1);
            } catch (err) {
              console.warn('invalid ws message', ev.data);
            }
          });

          ws.addEventListener('close', (ev) => {
            console.warn('WebSocket closed', ev.code, ev.reason);
            clearHeartbeat();
            ws = null;
            scheduleReconnect();
          });

          ws.addEventListener('error', (ev) => {
            console.error('WebSocket error', ev);
            // 多くの場合 error の後に close が来るため、ここでは再接続を待つ
          });
        }

        const main = async () => {
          try {
            const res = await fetch('https://pinattutaro.github.io/fest2025api/4u/env.json');
            const env = await res.json();
            uri = env.uri;
 
            const response = await fetch('./credentials.json');
            users = await response.json();
            console.log('Loaded users:', users);
          } catch (err) {
            console.warn('failed to load env.json', err);
            uri = ''; // 必要ならローカルで ws://localhost:...
          }
 
          // WebSocket 接続開始
          if (uri) connectWebSocket();
          showQr(0);
        };
 
        window.addEventListener('beforeunload', () => {
          if (ws) try { ws.close(); } catch (e) {}
          clearHeartbeat();
          if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
        });
 
        main();
      </script>
    </body>
    </html>
